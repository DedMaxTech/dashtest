// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Composable, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { AddFavoriteProjectData, AddFavoriteProjectError, AddFavoriteProjectResponse, AddLinkedIssuesData, AddLinkedIssuesError, AddLinkedIssuesResponse, AddNotificationSubscriptionData, AddNotificationSubscriptionError, AddNotificationSubscriptionResponse, AddProjectRepoPolicyData, AddProjectRepoPolicyError, AddProjectRepoPolicyResponse, AddProjectRepoPrAssigneesData, AddProjectRepoPrAssigneesError, AddProjectRepoPrAssigneesResponse, AddPullRequestViewedFileData, AddPullRequestViewedFileError, AddPullRequestViewedFileResponse, ApplyProjectRepoPatchData, ApplyProjectRepoPatchError, ApplyProjectRepoPatchResponse, ArchiveRepoData, ArchiveRepoError, ArchiveRepoResponse, AuthorsProjectRepoPrsData, AuthorsProjectRepoPrsError, AuthorsProjectRepoPrsResponse, CheckConnectionWebhookData, CheckConnectionWebhookError, CheckConnectionWebhookResponse, CheckTokenData, CheckTokenError, CheckTokenResponse, ConfigData, ConfigError, ConfigResponse, ConfigurePullRequestAutoMergeData, ConfigurePullRequestAutoMergeError, ConfigurePullRequestAutoMergeResponse, CountProjectRepoPrsData, CountProjectRepoPrsError, CountProjectRepoPrsResponse, CreateProjectData, CreateProjectError, CreateProjectRepoBranchData, CreateProjectRepoBranchError, CreateProjectRepoBranchResponse, CreateProjectRepoData, CreateProjectRepoError, CreateProjectRepoIssueData, CreateProjectRepoIssueError, CreateProjectRepoIssueResponse, CreateProjectRepoPrData, CreateProjectRepoPrError, CreateProjectRepoPrResponse, CreateProjectRepoResponse, CreateProjectRepoWebhookData, CreateProjectRepoWebhookError, CreateProjectRepoWebhookResponse, CreateProjectResponse, CreatePublicKeyData, CreatePublicKeyError, CreatePublicKeyResponse, CreateRepoForkData, CreateRepoForkError, CreateRepoForkResponse, CreateRepoStructureBranchData, CreateRepoStructureBranchError, CreateRepoStructureBranchResponse, CreateRepoStructurePathData, CreateRepoStructurePathError, CreateRepoStructurePathResponse, CreateServiceAccountData, CreateServiceAccountError, CreateServiceAccountResponse, CreateTagData, CreateTagError, CreateTagResponse, CreateTokenData, CreateTokenError, CreateTokenResponse, DeleteFavoriteProjectData, DeleteFavoriteProjectError, DeleteNotificationSubscriptionData, DeleteNotificationSubscriptionError, DeleteProjectData, DeleteProjectError, DeleteProjectRepoAutolinkSettingsData, DeleteProjectRepoAutolinkSettingsError, DeleteProjectRepoBranchData, DeleteProjectRepoBranchError, DeleteProjectRepoBranchesData, DeleteProjectRepoBranchesError, DeleteProjectRepoBranchesResponse, DeleteProjectRepoData, DeleteProjectRepoError, DeleteProjectRepoIssueData, DeleteProjectRepoIssueError, DeleteProjectRepoResponse, DeleteProjectRepoReviewerGroupData, DeleteProjectRepoReviewerGroupError, DeleteProjectRepoReviewerGroupResponse, DeleteProjectRepoWebhookData, DeleteProjectRepoWebhookError, DeleteProjectResponse, DeletePublicKeyData, DeletePublicKeyError, DeleteRepoStructureBranchData, DeleteRepoStructureBranchError, DeleteServiceAccountData, DeleteServiceAccountError, DeleteTagData, DeleteTagError, DeleteTagResponse, DeleteTokenData, DeleteTokenError, DisableProjectRepoMirrorData, DisableProjectRepoMirrorError, EnableProjectRepoMirrorData, EnableProjectRepoMirrorError, EnableProjectRepoMirrorResponse, EngrAuthResetCacheData, EngrAuthResetCacheError, GetBuildStatusData, GetBuildStatusError, GetBuildStatusResponse, GetBundleData, GetBundleError, GetJobData, GetJobError, GetJobResponse, GetNotificationSubscriptionInfoData, GetNotificationSubscriptionInfoError, GetNotificationSubscriptionInfoResponse, GetNotificationSubscriptionsData, GetNotificationSubscriptionsError, GetNotificationSubscriptionsResponse, GetProjectData, GetProjectError, GetProjectGroupsData, GetProjectGroupsError, GetProjectGroupsResponse, GetProjectRepoAutolinkSettingsData, GetProjectRepoAutolinkSettingsError, GetProjectRepoAutolinkSettingsResponse, GetProjectRepoBranchData, GetProjectRepoBranchError, GetProjectRepoBranchMetadataData, GetProjectRepoBranchMetadataError, GetProjectRepoBranchMetadataResponse, GetProjectRepoBranchResponse, GetProjectRepoCommitData, GetProjectRepoCommitDiffData, GetProjectRepoCommitDiffError, GetProjectRepoCommitDiffResponse, GetProjectRepoCommitError, GetProjectRepoCommitResponse, GetProjectRepoCommitsDiffData, GetProjectRepoCommitsDiffError, GetProjectRepoCommitsDiffResponse, GetProjectRepoContentData, GetProjectRepoContentError, GetProjectRepoContentResponse, GetProjectRepoData, GetProjectRepoError, GetProjectRepoFileBlameInfoData, GetProjectRepoFileBlameInfoError, GetProjectRepoFileBlameInfoResponse, GetProjectRepoFileData, GetProjectRepoFileError, GetProjectRepoFileResponse, GetProjectRepoFilesData, GetProjectRepoFilesError, GetProjectRepoFilesPathsData, GetProjectRepoFilesPathsError, GetProjectRepoFilesPathsResponse, GetProjectRepoFilesResponse, GetProjectRepoMirrorData, GetProjectRepoMirrorError, GetProjectRepoMirrorResponse, GetProjectRepoPrData, GetProjectRepoPrDiffData, GetProjectRepoPrDiffError, GetProjectRepoPrDiffResponse, GetProjectRepoPrError, GetProjectRepoProtectedBranchesSettingsData, GetProjectRepoProtectedBranchesSettingsError, GetProjectRepoProtectedBranchesSettingsResponse, GetProjectRepoPrResponse, GetProjectRepoRawFileData, GetProjectRepoRawFileError, GetProjectRepoResponse, GetProjectRepoTreeData, GetProjectRepoTreeError, GetProjectRepoTreeMetadataData, GetProjectRepoTreeMetadataError, GetProjectRepoTreeMetadataResponse, GetProjectRepoTreeResponse, GetProjectRepoWebhookData, GetProjectRepoWebhookError, GetProjectRepoWebhookResponse, GetProjectRepoWebhooksData, GetProjectRepoWebhooksError, GetProjectRepoWebhooksResponse, GetProjectResponse, GetPullRequestAutoMergeData, GetPullRequestAutoMergeError, GetPullRequestAutoMergeResponse, GetPullRequestMergeConflictsData, GetPullRequestMergeConflictsError, GetPullRequestMergeConflictsResponse, GetPullRequestViewedFilesData, GetPullRequestViewedFilesError, GetPullRequestViewedFilesResponse, GetRepoSearchSettingsData, GetRepoSearchSettingsError, GetRepoSearchSettingsResponse, GetRepoUsageQuotasData, GetRepoUsageQuotasError, GetRepoUsageQuotasResponse, GetServiceAccountData, GetServiceAccountError, GetServiceAccountResponse, GetServiceInformationData, GetServiceInformationError, GetServiceInformationResponse, GetUsageQuotasSettingsProjectData, GetUsageQuotasSettingsProjectError, GetUsageQuotasSettingsProjectResponse, GetUserData, GetUserError, GetUserResponse, GetUsersByLoginsData, GetUsersByLoginsError, GetUsersByLoginsResponse, GetUserSuggestionsData, GetUserSuggestionsError, GetUserSuggestionsResponse, HealthCheckData, ListProjectContentData, ListProjectContentError, ListProjectContentResponse, ListProjectRepoBranchesData, ListProjectRepoBranchesError, ListProjectRepoBranchesResponse, ListProjectRepoBranchesWithIssuesData, ListProjectRepoBranchesWithIssuesError, ListProjectRepoBranchesWithIssuesResponse, ListProjectRepoCommitsData, ListProjectRepoCommitsError, ListProjectRepoCommitsResponse, ListProjectRepoPolicyData, ListProjectRepoPolicyError, ListProjectRepoPolicyResponse, ListProjectRepoPrsData, ListProjectRepoPrsError, ListProjectRepoPrsResponse, ListProjectRepoPrTargetBranchesData, ListProjectRepoPrTargetBranchesError, ListProjectRepoPrTargetBranchesResponse, ListProjectRepoReviewerGroupsData, ListProjectRepoReviewerGroupsError, ListProjectRepoReviewerGroupsResponse, ListProjectReposData, ListProjectReposError, ListProjectReposResponse, ListProjectsData, ListProjectsError, ListProjectsResponse, ListPublicKeysData, ListPublicKeysError, ListPublicKeysResponse, ListPullRequestActivitiesData, ListPullRequestActivitiesError, ListPullRequestActivitiesResponse, ListRepoForksData, ListRepoForksError, ListRepoForksResponse, ListRepoStructureBranchData, ListRepoStructureBranchError, ListRepoStructureBranchResponse, ListRepoStructurePathData, ListRepoStructurePathError, ListRepoStructurePathResponse, ListServiceAccountEntitiesData, ListServiceAccountEntitiesError, ListServiceAccountEntitiesResponse, ListServiceAccountsData, ListServiceAccountsError, ListServiceAccountsResponse, ListTagsData, ListTagsError, ListTagsResponse, ListTokensData, ListTokensError, ListTokensResponse, ListUsersData, ListUsersError, ListUsersResponse, MergeProjectRepoPrData, MergeProjectRepoPrError, MergeProjectRepoPrResponse, PutUsageQuotasSettingsProjectData, PutUsageQuotasSettingsProjectError, PutUsageQuotasSettingsProjectResponse, RebasePullRequestSourceOnTargetData, RebasePullRequestSourceOnTargetError, RebasePullRequestSourceOnTargetResponse, RejectProjectRepoPrData, RejectProjectRepoPrError, RejectProjectRepoPrResponse, RemoveLinkedIssuesData, RemoveLinkedIssuesError, RemoveProjectRepoPrAssigneesData, RemoveProjectRepoPrAssigneesError, RemoveProjectRepoPrAssigneesResponse, RemovePullRequestViewedFileData, RemovePullRequestViewedFileError, RemovePullRequestViewedFileResponse, ReopenProjectRepoPrData, ReopenProjectRepoPrError, ReopenProjectRepoPrResponse, ResolvePullRequestMergeConflictsData, ResolvePullRequestMergeConflictsError, ResolvePullRequestMergeConflictsResponse, RunJobData, RunJobError, RunJobResponse, SearchTextInSourceCodeData, SearchTextInSourceCodeError, SearchTextInSourceCodeResponse, SelfData, SelfError, SelfResponse, SetProjectRepoAutolinkSettingsData, SetProjectRepoAutolinkSettingsError, SetProjectRepoAutolinkSettingsResponse, SetProjectRepoPrAssigneeDecisionData, SetProjectRepoPrAssigneeDecisionError, SetProjectRepoPrAssigneeDecisionResponse, SetProjectRepoProtectedBranchesSettingsData, SetProjectRepoProtectedBranchesSettingsError, SetProjectRepoProtectedBranchesSettingsResponse, SetProjectRepoReviewerGroupData, SetProjectRepoReviewerGroupError, SetProjectRepoReviewerGroupResponse, SetRepoSearchSettingsData, SetRepoSearchSettingsError, SetRepoSearchSettingsResponse, StartProjectRepoMigrationData, StartProjectRepoMigrationError, StartProjectRepoMigrationResponse, StartRepositoriesMigrationData, StartRepositoriesMigrationError, StartRepositoriesMigrationResponse, UpdateMergeBranchData, UpdateMergeBranchError, UpdateMergeBranchResponse, UpdateProjectData, UpdateProjectError, UpdateProjectRepoAutolinkSettingsData, UpdateProjectRepoAutolinkSettingsError, UpdateProjectRepoAutolinkSettingsResponse, UpdateProjectRepoData, UpdateProjectRepoError, UpdateProjectRepoIssueData, UpdateProjectRepoIssueError, UpdateProjectRepoIssueResponse, UpdateProjectRepoPrData, UpdateProjectRepoPrError, UpdateProjectRepoPrResponse, UpdateProjectRepoResponse, UpdateProjectRepoWebhookData, UpdateProjectRepoWebhookError, UpdateProjectRepoWebhookResponse, UpdateProjectResponse, UpdatePublicKeyData, UpdatePublicKeyError, UpdatePublicKeyResponse, UpdatePullRequestAutoMergeData, UpdatePullRequestAutoMergeError, UpdatePullRequestAutoMergeResponse, UpdateRepoStructureBranchData, UpdateRepoStructureBranchError, UpdateRepoStructureBranchResponse, UpdateServiceAccountData, UpdateServiceAccountError, UpdateServiceAccountResponse, UpdateTokenData, UpdateTokenError, UpdateTokenResponse, VersionCheckData } from './types.gen';

export type Options<TComposable extends Composable = '$fetch', TData extends TDataShape = TDataShape, ResT = unknown, DefaultT = undefined> = Options2<TComposable, TData, ResT, DefaultT> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Resets the cache.
 *
 * Resets the cache that stores all access rights for users.
 * If query is not passed, then we reset the entire cache; if passed, then only certain parameters
 * Datasource: DB
 */
export const engrAuthResetCache = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, EngrAuthResetCacheData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, EngrAuthResetCacheError, DefaultT>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/cache/permissions',
        ...options
    });
};

/**
 * Get limits from app config.
 */
export const config = <TComposable extends Composable = '$fetch', DefaultT extends ConfigResponse = ConfigResponse>(options: Options<TComposable, ConfigData, ConfigResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ConfigResponse | DefaultT, ConfigError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/config',
        ...options
    });
};

/**
 * Delete a favorite project.
 *
 * Delete a favorite project.
 * Datasource: Git
 */
export const deleteFavoriteProject = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteFavoriteProjectData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteFavoriteProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/favorite/projects/{projectKey}',
        ...options
    });
};

/**
 * Create a favorite project.
 *
 * Create a favorite project.
 * Datasource: DB
 */
export const addFavoriteProject = <TComposable extends Composable = '$fetch', DefaultT extends AddFavoriteProjectResponse = AddFavoriteProjectResponse>(options: Options<TComposable, AddFavoriteProjectData, AddFavoriteProjectResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, AddFavoriteProjectResponse | DefaultT, AddFavoriteProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/favorite/projects/{projectKey}',
        ...options
    });
};

/**
 * Health check
 *
 * Check the functionality of the service
 */
export const healthCheck = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, HealthCheckData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/health',
        ...options
    });
};

/**
 * Runs a new job.
 *
 * Runs a new job.
 * Datasource: DB, Job
 */
export const runJob = <TComposable extends Composable = '$fetch', DefaultT extends RunJobResponse = RunJobResponse>(options: Options<TComposable, RunJobData, RunJobResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, RunJobResponse | DefaultT, RunJobError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/jobs/run',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get an existing background job state.
 *
 * Get an existing background job state.
 * Datasource: DB, Job
 */
export const getJob = <TComposable extends Composable = '$fetch', DefaultT extends GetJobResponse = GetJobResponse>(options: Options<TComposable, GetJobData, GetJobResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetJobResponse | DefaultT, GetJobError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/jobs/{jobId}',
        ...options
    });
};

/**
 * List projects
 *
 * Paginated list of projects.
 * Datasource: DB
 */
export const listProjects = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectsResponse = ListProjectsResponse>(options: Options<TComposable, ListProjectsData, ListProjectsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectsResponse | DefaultT, ListProjectsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects',
        ...options
    });
};

/**
 * Create a new project.
 *
 * Create a new project.
 * Datasource: DB
 */
export const createProject = <TComposable extends Composable = '$fetch', DefaultT extends CreateProjectResponse = CreateProjectResponse>(options: Options<TComposable, CreateProjectData, CreateProjectResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateProjectResponse | DefaultT, CreateProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Start a project repository migration.
 *
 * Start a project repository migration.
 * Datasource: DB, Git, Job
 */
export const startRepositoriesMigration = <TComposable extends Composable = '$fetch', DefaultT extends StartRepositoriesMigrationResponse = StartRepositoriesMigrationResponse>(options: Options<TComposable, StartRepositoriesMigrationData, StartRepositoriesMigrationResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, StartRepositoriesMigrationResponse | DefaultT, StartRepositoriesMigrationError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/repos/migration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete an existing project.
 *
 * Delete an existing project and all the project repositories.
 * Datasource: DB
 */
export const deleteProject = <TComposable extends Composable = '$fetch', DefaultT extends DeleteProjectResponse = DeleteProjectResponse>(options: Options<TComposable, DeleteProjectData, DeleteProjectResponse, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, DeleteProjectResponse | DefaultT, DeleteProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}',
        ...options
    });
};

/**
 * Get an existing project.
 *
 * Get an existing project.
 * Datasource: DB
 */
export const getProject = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectResponse = GetProjectResponse>(options: Options<TComposable, GetProjectData, GetProjectResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectResponse | DefaultT, GetProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}',
        ...options
    });
};

/**
 * Update an existing project.
 *
 * Update an existing project fields. At least one input field must be provided.
 * Datasource: DB
 */
export const updateProject = <TComposable extends Composable = '$fetch', DefaultT extends UpdateProjectResponse = UpdateProjectResponse>(options: Options<TComposable, UpdateProjectData, UpdateProjectResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateProjectResponse | DefaultT, UpdateProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List a project content.
 *
 * Paginated list of a project groups & repos.
 * Datasource: DB
 */
export const listProjectContent = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectContentResponse = ListProjectContentResponse>(options: Options<TComposable, ListProjectContentData, ListProjectContentResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectContentResponse | DefaultT, ListProjectContentError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/content',
        ...options
    });
};

/**
 * Get project groups.
 *
 * Get project groups.
 * Datasource: DB
 */
export const getProjectGroups = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectGroupsResponse = GetProjectGroupsResponse>(options: Options<TComposable, GetProjectGroupsData, GetProjectGroupsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectGroupsResponse | DefaultT, GetProjectGroupsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/groups',
        ...options
    });
};

/**
 * List a project repos.
 *
 * Paginated list of a project repos.
 * Datasource: DB
 */
export const listProjectRepos = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectReposResponse = ListProjectReposResponse>(options: Options<TComposable, ListProjectReposData, ListProjectReposResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectReposResponse | DefaultT, ListProjectReposError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos',
        ...options
    });
};

/**
 * Create a project repository.
 *
 * Create a project repository.
 * Datasource: DB, Git
 */
export const createProjectRepo = <TComposable extends Composable = '$fetch', DefaultT extends CreateProjectRepoResponse = CreateProjectRepoResponse>(options: Options<TComposable, CreateProjectRepoData, CreateProjectRepoResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateProjectRepoResponse | DefaultT, CreateProjectRepoError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a project repository.
 *
 * Delete a project repository.
 * Datasource: DB, Git, Job
 */
export const deleteProjectRepo = <TComposable extends Composable = '$fetch', DefaultT extends DeleteProjectRepoResponse = DeleteProjectRepoResponse>(options: Options<TComposable, DeleteProjectRepoData, DeleteProjectRepoResponse, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, DeleteProjectRepoResponse | DefaultT, DeleteProjectRepoError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}',
        ...options
    });
};

/**
 * Get an existing project repository.
 *
 * Get an existing project repository.
 * Datasource: DB
 */
export const getProjectRepo = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoResponse = GetProjectRepoResponse>(options: Options<TComposable, GetProjectRepoData, GetProjectRepoResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoResponse | DefaultT, GetProjectRepoError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}',
        ...options
    });
};

/**
 * Update a project repository.
 *
 * Update a project repository.
 * Datasource: DB, Git
 */
export const updateProjectRepo = <TComposable extends Composable = '$fetch', DefaultT extends UpdateProjectRepoResponse = UpdateProjectRepoResponse>(options: Options<TComposable, UpdateProjectRepoData, UpdateProjectRepoResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateProjectRepoResponse | DefaultT, UpdateProjectRepoError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Archive a repository.
 *
 * Archive a repository.
 * Datasource: Git
 */
export const archiveRepo = <TComposable extends Composable = '$fetch', DefaultT extends ArchiveRepoResponse = ArchiveRepoResponse>(options: Options<TComposable, ArchiveRepoData, ArchiveRepoResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ArchiveRepoResponse | DefaultT, ArchiveRepoError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/archive/{gitRev}.{format}',
        ...options
    });
};

/**
 * Get a project repository file blame info.
 *
 * Get a project repository file blame info.
 * Datasource: Git
 */
export const getProjectRepoFileBlameInfo = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoFileBlameInfoResponse = GetProjectRepoFileBlameInfoResponse>(options: Options<TComposable, GetProjectRepoFileBlameInfoData, GetProjectRepoFileBlameInfoResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoFileBlameInfoResponse | DefaultT, GetProjectRepoFileBlameInfoError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/blame/{treePath}',
        ...options
    });
};

/**
 * Delete project repository branches (by condition).
 *
 * Delete project repository branches (by condition).
 * Datasource: Git
 */
export const deleteProjectRepoBranches = <TComposable extends Composable = '$fetch', DefaultT extends DeleteProjectRepoBranchesResponse = DeleteProjectRepoBranchesResponse>(options: Options<TComposable, DeleteProjectRepoBranchesData, DeleteProjectRepoBranchesResponse, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, DeleteProjectRepoBranchesResponse | DefaultT, DeleteProjectRepoBranchesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/branches',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List project repository branches (all).
 *
 * List project repository branches (all).
 * Datasource: Git
 */
export const listProjectRepoBranches = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectRepoBranchesResponse = ListProjectRepoBranchesResponse>(options: Options<TComposable, ListProjectRepoBranchesData, ListProjectRepoBranchesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectRepoBranchesResponse | DefaultT, ListProjectRepoBranchesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/branches',
        ...options
    });
};

/**
 * Create a project repository branch.
 *
 * Create a project repository branch.
 * Datasource: Git
 */
export const createProjectRepoBranch = <TComposable extends Composable = '$fetch', DefaultT extends CreateProjectRepoBranchResponse = CreateProjectRepoBranchResponse>(options: Options<TComposable, CreateProjectRepoBranchData, CreateProjectRepoBranchResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateProjectRepoBranchResponse | DefaultT, CreateProjectRepoBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/branches',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get a project repository branch metadata.
 *
 * Get a project repository branch metadata.
 * Datasource: DB, Git
 */
export const getProjectRepoBranchMetadata = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoBranchMetadataResponse = GetProjectRepoBranchMetadataResponse>(options: Options<TComposable, GetProjectRepoBranchMetadataData, GetProjectRepoBranchMetadataResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, GetProjectRepoBranchMetadataResponse | DefaultT, GetProjectRepoBranchMetadataError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/branches/metadata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a project repository branch.
 *
 * Delete a project repository branch.
 * Datasource: Git
 */
export const deleteProjectRepoBranch = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteProjectRepoBranchData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteProjectRepoBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/branches/{branchName}',
        ...options
    });
};

/**
 * Get a project repository branch.
 *
 * Get a project repository branch.
 * Datasource: Git
 */
export const getProjectRepoBranch = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoBranchResponse = GetProjectRepoBranchResponse>(options: Options<TComposable, GetProjectRepoBranchData, GetProjectRepoBranchResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoBranchResponse | DefaultT, GetProjectRepoBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/branches/{branchName}',
        ...options
    });
};

/**
 * Get an existing bundle.
 *
 * Get an existing bundle.
 * Datasource: Codilo/S3
 */
export const getBundle = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, GetBundleData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, GetBundleError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/bundles/{bundleId}',
        ...options
    });
};

/**
 * List project repository commits.
 *
 * Paginated list of a project repo commits.
 * Datasource: Git
 */
export const listProjectRepoCommits = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectRepoCommitsResponse = ListProjectRepoCommitsResponse>(options: Options<TComposable, ListProjectRepoCommitsData, ListProjectRepoCommitsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectRepoCommitsResponse | DefaultT, ListProjectRepoCommitsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/commits',
        ...options
    });
};

/**
 * Get project repository commits diff.
 *
 * Get project repository commits diff.
 * Datasource: Git
 */
export const getProjectRepoCommitsDiff = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoCommitsDiffResponse = GetProjectRepoCommitsDiffResponse>(options: Options<TComposable, GetProjectRepoCommitsDiffData, GetProjectRepoCommitsDiffResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoCommitsDiffResponse | DefaultT, GetProjectRepoCommitsDiffError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/commits/diff',
        ...options
    });
};

/**
 * Get project repository commit.
 *
 * Get project repository commit.
 * Datasource: Git
 */
export const getProjectRepoCommit = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoCommitResponse = GetProjectRepoCommitResponse>(options: Options<TComposable, GetProjectRepoCommitData, GetProjectRepoCommitResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoCommitResponse | DefaultT, GetProjectRepoCommitError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/commits/{sha1}',
        ...options
    });
};

/**
 * Get project repository commit diff.
 *
 * Get project repository commit diff.
 * Datasource: Git
 */
export const getProjectRepoCommitDiff = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoCommitDiffResponse = GetProjectRepoCommitDiffResponse>(options: Options<TComposable, GetProjectRepoCommitDiffData, GetProjectRepoCommitDiffResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoCommitDiffResponse | DefaultT, GetProjectRepoCommitDiffError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/commits/{sha1}/diff',
        ...options
    });
};

/**
 * Get a project repository content metadata.
 *
 * Get a project repository content metadata.
 * Datasource: Git
 *
 * @deprecated
 */
export const getProjectRepoContent = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoContentResponse = GetProjectRepoContentResponse>(options: Options<TComposable, GetProjectRepoContentData, GetProjectRepoContentResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoContentResponse | DefaultT, GetProjectRepoContentError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/content/{treePath}',
        ...options
    });
};

/**
 * Get a project repository file content.
 *
 * Get a project repository file content.
 * Datasource: Git
 */
export const getProjectRepoFile = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoFileResponse = GetProjectRepoFileResponse>(options: Options<TComposable, GetProjectRepoFileData, GetProjectRepoFileResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoFileResponse | DefaultT, GetProjectRepoFileError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/file/{treePath}',
        ...options
    });
};

/**
 * Get a project repository files paths relative to root by pattern.
 *
 * Get a project repository files paths relative to root by pattern.
 * Datasource: Git
 */
export const getProjectRepoFilesPaths = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoFilesPathsResponse = GetProjectRepoFilesPathsResponse>(options: Options<TComposable, GetProjectRepoFilesPathsData, GetProjectRepoFilesPathsResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, GetProjectRepoFilesPathsResponse | DefaultT, GetProjectRepoFilesPathsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/file_path',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get project repository files contents.
 *
 * Get project repository files contents.
 * Datasource: Git
 */
export const getProjectRepoFiles = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoFilesResponse = GetProjectRepoFilesResponse>(options: Options<TComposable, GetProjectRepoFilesData, GetProjectRepoFilesResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, GetProjectRepoFilesResponse | DefaultT, GetProjectRepoFilesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create a project repository fork.
 *
 * Create a project repository fork.
 * Datasource: database
 */
export const createRepoFork = <TComposable extends Composable = '$fetch', DefaultT extends CreateRepoForkResponse = CreateRepoForkResponse>(options: Options<TComposable, CreateRepoForkData, CreateRepoForkResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateRepoForkResponse | DefaultT, CreateRepoForkError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/fork',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List a repository forks.
 *
 * Get a list of a repository forks.
 * Datasource: DB
 */
export const listRepoForks = <TComposable extends Composable = '$fetch', DefaultT extends ListRepoForksResponse = ListRepoForksResponse>(options: Options<TComposable, ListRepoForksData, ListRepoForksResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListRepoForksResponse | DefaultT, ListRepoForksError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/forks',
        ...options
    });
};

/**
 * List project repository branches (all) with an issue assigned.
 *
 * List project repository branches (all) with an issue assigned.
 * Datasource: DB, Git
 */
export const listProjectRepoBranchesWithIssues = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectRepoBranchesWithIssuesResponse = ListProjectRepoBranchesWithIssuesResponse>(options: Options<TComposable, ListProjectRepoBranchesWithIssuesData, ListProjectRepoBranchesWithIssuesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectRepoBranchesWithIssuesResponse | DefaultT, ListProjectRepoBranchesWithIssuesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/issues',
        ...options
    });
};

/**
 * Create an issue for the project repository branch.
 *
 * Create an issue for the project repository branch.
 * Datasource: DB
 */
export const createProjectRepoIssue = <TComposable extends Composable = '$fetch', DefaultT extends CreateProjectRepoIssueResponse = CreateProjectRepoIssueResponse>(options: Options<TComposable, CreateProjectRepoIssueData, CreateProjectRepoIssueResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateProjectRepoIssueResponse | DefaultT, CreateProjectRepoIssueError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/issues',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete an existing issue for the project repository branch.
 *
 * Delete an existing issue for the project repository branch.
 * Datasource: DB
 */
export const deleteProjectRepoIssue = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteProjectRepoIssueData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteProjectRepoIssueError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/issues/{branchName}',
        ...options
    });
};

/**
 * Update an existing issue for the project repository branch.
 *
 * Update an existing issue for the project repository branch.
 * Datasource: DB
 */
export const updateProjectRepoIssue = <TComposable extends Composable = '$fetch', DefaultT extends UpdateProjectRepoIssueResponse = UpdateProjectRepoIssueResponse>(options: Options<TComposable, UpdateProjectRepoIssueData, UpdateProjectRepoIssueResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateProjectRepoIssueResponse | DefaultT, UpdateProjectRepoIssueError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/issues/{branchName}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Start a project repository migration.
 *
 * Start a project repository migration.
 * Datasource: DB, Git, Job
 */
export const startProjectRepoMigration = <TComposable extends Composable = '$fetch', DefaultT extends StartProjectRepoMigrationResponse = StartProjectRepoMigrationResponse>(options: Options<TComposable, StartProjectRepoMigrationData, StartProjectRepoMigrationResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, StartProjectRepoMigrationResponse | DefaultT, StartProjectRepoMigrationError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/migration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Apply a project repository patch.
 *
 * Apply a project repository patch.
 * Datasource: Git
 */
export const applyProjectRepoPatch = <TComposable extends Composable = '$fetch', DefaultT extends ApplyProjectRepoPatchResponse = ApplyProjectRepoPatchResponse>(options: Options<TComposable, ApplyProjectRepoPatchData, ApplyProjectRepoPatchResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, ApplyProjectRepoPatchResponse | DefaultT, ApplyProjectRepoPatchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/patch',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get an existing repository pull requests list.
 *
 * Get an existing repository pull requests list.
 * Datasource: DB
 */
export const listProjectRepoPrs = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectRepoPrsResponse = ListProjectRepoPrsResponse>(options: Options<TComposable, ListProjectRepoPrsData, ListProjectRepoPrsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectRepoPrsResponse | DefaultT, ListProjectRepoPrsError, DefaultT>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests',
        ...options
    });
};

/**
 * Create new repository pull request.
 *
 * Create new repository pull request.
 * Datasource: DB, Git, Job
 */
export const createProjectRepoPr = <TComposable extends Composable = '$fetch', DefaultT extends CreateProjectRepoPrResponse = CreateProjectRepoPrResponse>(options: Options<TComposable, CreateProjectRepoPrData, CreateProjectRepoPrResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateProjectRepoPrResponse | DefaultT, CreateProjectRepoPrError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get the authors of pull requests.
 *
 * Get the authors of pull requests.
 * Datasource: DB
 */
export const authorsProjectRepoPrs = <TComposable extends Composable = '$fetch', DefaultT extends AuthorsProjectRepoPrsResponse = AuthorsProjectRepoPrsResponse>(options: Options<TComposable, AuthorsProjectRepoPrsData, AuthorsProjectRepoPrsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, AuthorsProjectRepoPrsResponse | DefaultT, AuthorsProjectRepoPrsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/authors',
        ...options
    });
};

/**
 * Get the count of pull requests depending on status on Open, Merged, Rejected.
 *
 * Get the count of pull requests depending on status on Open, Merged, Rejected.
 * Datasource: DB
 */
export const countProjectRepoPrs = <TComposable extends Composable = '$fetch', DefaultT extends CountProjectRepoPrsResponse = CountProjectRepoPrsResponse>(options: Options<TComposable, CountProjectRepoPrsData, CountProjectRepoPrsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, CountProjectRepoPrsResponse | DefaultT, CountProjectRepoPrsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/counters',
        ...options
    });
};

/**
 * Get a sorted by name list of target branches for all repo PRs.
 *
 * Get a sorted by name list of target branches for all repo PRs.
 * Datasource: DB
 */
export const listProjectRepoPrTargetBranches = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectRepoPrTargetBranchesResponse = ListProjectRepoPrTargetBranchesResponse>(options: Options<TComposable, ListProjectRepoPrTargetBranchesData, ListProjectRepoPrTargetBranchesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectRepoPrTargetBranchesResponse | DefaultT, ListProjectRepoPrTargetBranchesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/target-branches',
        ...options
    });
};

/**
 * Get user suggestions for specified pull request.
 *
 * Get user suggestions for specified pull request.
 */
export const getUserSuggestions = <TComposable extends Composable = '$fetch', DefaultT extends GetUserSuggestionsResponse = GetUserSuggestionsResponse>(options: Options<TComposable, GetUserSuggestionsData, GetUserSuggestionsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetUserSuggestionsResponse | DefaultT, GetUserSuggestionsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/user-suggestions',
        ...options
    });
};

/**
 * Get an existing repository pull request.
 *
 * Get an existing repository pull request.
 * Datasource: DB
 */
export const getProjectRepoPr = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoPrResponse = GetProjectRepoPrResponse>(options: Options<TComposable, GetProjectRepoPrData, GetProjectRepoPrResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoPrResponse | DefaultT, GetProjectRepoPrError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}',
        ...options
    });
};

/**
 * Update an existing pull request.
 *
 * Update an existing pull request fields. This method can return 200 alongside errors due to partially successful update.
 * Datasource: DB
 */
export const updateProjectRepoPr = <TComposable extends Composable = '$fetch', DefaultT extends UpdateProjectRepoPrResponse = UpdateProjectRepoPrResponse>(options: Options<TComposable, UpdateProjectRepoPrData, UpdateProjectRepoPrResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateProjectRepoPrResponse | DefaultT, UpdateProjectRepoPrError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Lists pull request activities.
 *
 * Lists users and background processes activities associated with the pull request.
 */
export const listPullRequestActivities = <TComposable extends Composable = '$fetch', DefaultT extends ListPullRequestActivitiesResponse = ListPullRequestActivitiesResponse>(options: Options<TComposable, ListPullRequestActivitiesData, ListPullRequestActivitiesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListPullRequestActivitiesResponse | DefaultT, ListPullRequestActivitiesError, DefaultT>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/activities',
        ...options
    });
};

/**
 * Remove assignees from pull request.
 *
 * Remove assignees from pull request.
 * Datasource: DB
 *
 * @deprecated
 */
export const removeProjectRepoPrAssignees = <TComposable extends Composable = '$fetch', DefaultT extends RemoveProjectRepoPrAssigneesResponse = RemoveProjectRepoPrAssigneesResponse>(options: Options<TComposable, RemoveProjectRepoPrAssigneesData, RemoveProjectRepoPrAssigneesResponse, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, RemoveProjectRepoPrAssigneesResponse | DefaultT, RemoveProjectRepoPrAssigneesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/assignees',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Add assignees to pull request.
 *
 * Add assignees to pull request.
 * Datasource: DB
 *
 * @deprecated
 */
export const addProjectRepoPrAssignees = <TComposable extends Composable = '$fetch', DefaultT extends AddProjectRepoPrAssigneesResponse = AddProjectRepoPrAssigneesResponse>(options: Options<TComposable, AddProjectRepoPrAssigneesData, AddProjectRepoPrAssigneesResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, AddProjectRepoPrAssigneesResponse | DefaultT, AddProjectRepoPrAssigneesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/assignees',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get auto merge configuration for pull request.
 *
 * Get auto merge configuration for pull request.
 * Datasource: DB
 *
 * Warning! Response field 'data' can be empty as indication of not found (CODE-4087).
 */
export const getPullRequestAutoMerge = <TComposable extends Composable = '$fetch', DefaultT extends GetPullRequestAutoMergeResponse = GetPullRequestAutoMergeResponse>(options: Options<TComposable, GetPullRequestAutoMergeData, GetPullRequestAutoMergeResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetPullRequestAutoMergeResponse | DefaultT, GetPullRequestAutoMergeError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/auto-merge',
        ...options
    });
};

/**
 * Update auto merge for pull request.
 *
 * Update auto merge for pull request.
 * Datasource: DB
 */
export const updatePullRequestAutoMerge = <TComposable extends Composable = '$fetch', DefaultT extends UpdatePullRequestAutoMergeResponse = UpdatePullRequestAutoMergeResponse>(options: Options<TComposable, UpdatePullRequestAutoMergeData, UpdatePullRequestAutoMergeResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdatePullRequestAutoMergeResponse | DefaultT, UpdatePullRequestAutoMergeError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/auto-merge',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Enable auto merge for pull request.
 *
 * Enable auto merge for pull request.
 * Datasource: DB
 */
export const configurePullRequestAutoMerge = <TComposable extends Composable = '$fetch', DefaultT extends ConfigurePullRequestAutoMergeResponse = ConfigurePullRequestAutoMergeResponse>(options: Options<TComposable, ConfigurePullRequestAutoMergeData, ConfigurePullRequestAutoMergeResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, ConfigurePullRequestAutoMergeResponse | DefaultT, ConfigurePullRequestAutoMergeError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/auto-merge',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get CI/CD build status.
 *
 * Get CI/CD build status.
 *
 * Warning! Response field 'data' can be empty as indication of not found (CODE-4087). The API is deprecated, 'builds' operation should be used instead.
 *
 * @deprecated
 */
export const getBuildStatus = <TComposable extends Composable = '$fetch', DefaultT extends GetBuildStatusResponse = GetBuildStatusResponse>(options: Options<TComposable, GetBuildStatusData, GetBuildStatusResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetBuildStatusResponse | DefaultT, GetBuildStatusError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/build',
        ...options
    });
};

/**
 * Set pull request assignee decision. The user needs to be an assignee of the pull request.
 *
 * Set pull request assignee decision. The user needs to be an assignee of the pull request.
 * Datasource: DB
 */
export const setProjectRepoPrAssigneeDecision = <TComposable extends Composable = '$fetch', DefaultT extends SetProjectRepoPrAssigneeDecisionResponse = SetProjectRepoPrAssigneeDecisionResponse>(options: Options<TComposable, SetProjectRepoPrAssigneeDecisionData, SetProjectRepoPrAssigneeDecisionResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, SetProjectRepoPrAssigneeDecisionResponse | DefaultT, SetProjectRepoPrAssigneeDecisionError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/decision',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get an existing repository pull request diff.
 *
 * Get an existing repository pull request diff.
 * Datasource: DB, Git
 */
export const getProjectRepoPrDiff = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoPrDiffResponse = GetProjectRepoPrDiffResponse>(options: Options<TComposable, GetProjectRepoPrDiffData, GetProjectRepoPrDiffResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoPrDiffResponse | DefaultT, GetProjectRepoPrDiffError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/diff',
        ...options
    });
};

/**
 * Remove linked issues to pull request.
 *
 * Remove linked issues to pull request.
 * Datasource: DB
 */
export const removeLinkedIssues = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, RemoveLinkedIssuesData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, RemoveLinkedIssuesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/linked-issues',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Add linked issues to pull request.
 *
 * Add linked issues to pull request.
 * Datasource: DB
 */
export const addLinkedIssues = <TComposable extends Composable = '$fetch', DefaultT extends AddLinkedIssuesResponse = AddLinkedIssuesResponse>(options: Options<TComposable, AddLinkedIssuesData, AddLinkedIssuesResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, AddLinkedIssuesResponse | DefaultT, AddLinkedIssuesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/linked-issues',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Merge repository pull request.
 *
 * In order to merge a pull request, merge settings must be followed (min approves, max declines).
 * Datasource: DB, Git
 */
export const mergeProjectRepoPr = <TComposable extends Composable = '$fetch', DefaultT extends MergeProjectRepoPrResponse = MergeProjectRepoPrResponse>(options: Options<TComposable, MergeProjectRepoPrData, MergeProjectRepoPrResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, MergeProjectRepoPrResponse | DefaultT, MergeProjectRepoPrError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/merge',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get pull request's merge conflicts.
 *
 * Get pull request's merge conflicts.
 * Datasource: DB, Git
 */
export const getPullRequestMergeConflicts = <TComposable extends Composable = '$fetch', DefaultT extends GetPullRequestMergeConflictsResponse = GetPullRequestMergeConflictsResponse>(options: Options<TComposable, GetPullRequestMergeConflictsData, GetPullRequestMergeConflictsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetPullRequestMergeConflictsResponse | DefaultT, GetPullRequestMergeConflictsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/merge-conflicts',
        ...options
    });
};

/**
 * Rebase pull request's source branch on target one.
 *
 * Rebase pull request's source branch on target one.
 */
export const rebasePullRequestSourceOnTarget = <TComposable extends Composable = '$fetch', DefaultT extends RebasePullRequestSourceOnTargetResponse = RebasePullRequestSourceOnTargetResponse>(options: Options<TComposable, RebasePullRequestSourceOnTargetData, RebasePullRequestSourceOnTargetResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, RebasePullRequestSourceOnTargetResponse | DefaultT, RebasePullRequestSourceOnTargetError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/rebase',
        ...options
    });
};

/**
 * Reject an existing pull request.
 *
 * Reject an existing pull request.
 * Datasource: DB
 */
export const rejectProjectRepoPr = <TComposable extends Composable = '$fetch', DefaultT extends RejectProjectRepoPrResponse = RejectProjectRepoPrResponse>(options: Options<TComposable, RejectProjectRepoPrData, RejectProjectRepoPrResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, RejectProjectRepoPrResponse | DefaultT, RejectProjectRepoPrError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/reject',
        ...options
    });
};

/**
 * Reopen an existing closed pull request.
 *
 * Reopen an existing closed pull request.
 * Datasource: DB,GIT
 */
export const reopenProjectRepoPr = <TComposable extends Composable = '$fetch', DefaultT extends ReopenProjectRepoPrResponse = ReopenProjectRepoPrResponse>(options: Options<TComposable, ReopenProjectRepoPrData, ReopenProjectRepoPrResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, ReopenProjectRepoPrResponse | DefaultT, ReopenProjectRepoPrError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/reopen',
        ...options
    });
};

/**
 * Resolve pull request's merge conflicts.
 *
 * Resolve pull request's merge conflicts.
 * Datasource: DB, Git
 */
export const resolvePullRequestMergeConflicts = <TComposable extends Composable = '$fetch', DefaultT extends ResolvePullRequestMergeConflictsResponse = ResolvePullRequestMergeConflictsResponse>(options: Options<TComposable, ResolvePullRequestMergeConflictsData, ResolvePullRequestMergeConflictsResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, ResolvePullRequestMergeConflictsResponse | DefaultT, ResolvePullRequestMergeConflictsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/resolve-conflicts',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Update pull request merge branch.
 *
 * Update pull request merge branch.
 * Datasource: DB, GIT
 */
export const updateMergeBranch = <TComposable extends Composable = '$fetch', DefaultT extends UpdateMergeBranchResponse = UpdateMergeBranchResponse>(options: Options<TComposable, UpdateMergeBranchData, UpdateMergeBranchResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, UpdateMergeBranchResponse | DefaultT, UpdateMergeBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/update-merge-branch',
        ...options
    });
};

/**
 * Remove viewed status from file in the pull request.
 *
 * Remove viewed status from file in the pull request.
 * Datasource: DB
 */
export const removePullRequestViewedFile = <TComposable extends Composable = '$fetch', DefaultT extends RemovePullRequestViewedFileResponse = RemovePullRequestViewedFileResponse>(options: Options<TComposable, RemovePullRequestViewedFileData, RemovePullRequestViewedFileResponse, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, RemovePullRequestViewedFileResponse | DefaultT, RemovePullRequestViewedFileError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/viewed-files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get list of viewed files in the pull request.
 *
 * Get list of viewed files in the pull request.
 * Datasource: DB,GIT
 */
export const getPullRequestViewedFiles = <TComposable extends Composable = '$fetch', DefaultT extends GetPullRequestViewedFilesResponse = GetPullRequestViewedFilesResponse>(options: Options<TComposable, GetPullRequestViewedFilesData, GetPullRequestViewedFilesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetPullRequestViewedFilesResponse | DefaultT, GetPullRequestViewedFilesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/viewed-files',
        ...options
    });
};

/**
 * Mark file as viewed by the user in the pull request.
 *
 * Mark file as viewed by the user in the pull request.
 * Datasource: DB,GIT
 */
export const addPullRequestViewedFile = <TComposable extends Composable = '$fetch', DefaultT extends AddPullRequestViewedFileResponse = AddPullRequestViewedFileResponse>(options: Options<TComposable, AddPullRequestViewedFileData, AddPullRequestViewedFileResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, AddPullRequestViewedFileResponse | DefaultT, AddPullRequestViewedFileError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/pull-requests/{prId}/viewed-files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get a project repository raw file content.
 *
 * Get a project repository raw file content.
 * The current version supports both raw/file* and file/raw*.
 * Datasource: Git
 */
export const getProjectRepoRawFile = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, GetProjectRepoRawFileData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, GetProjectRepoRawFileError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/raw/file/{treePath}',
        ...options
    });
};

/**
 * Search text in source code.
 *
 * Search text in source code.
 */
export const searchTextInSourceCode = <TComposable extends Composable = '$fetch', DefaultT extends SearchTextInSourceCodeResponse = SearchTextInSourceCodeResponse>(options: Options<TComposable, SearchTextInSourceCodeData, SearchTextInSourceCodeResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, SearchTextInSourceCodeResponse | DefaultT, SearchTextInSourceCodeError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Deletes autolink settings for an existing project repository.
 *
 * Deletes autolink settings for an existing project repository.
 * Datasource: DB
 */
export const deleteProjectRepoAutolinkSettings = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteProjectRepoAutolinkSettingsData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteProjectRepoAutolinkSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/autolink',
        ...options
    });
};

/**
 * Get an existing project repository autolink settings.
 *
 * Get an existing project repository autolink settings.
 * Datasource: DB
 */
export const getProjectRepoAutolinkSettings = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoAutolinkSettingsResponse = GetProjectRepoAutolinkSettingsResponse>(options: Options<TComposable, GetProjectRepoAutolinkSettingsData, GetProjectRepoAutolinkSettingsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoAutolinkSettingsResponse | DefaultT, GetProjectRepoAutolinkSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/autolink',
        ...options
    });
};

/**
 * Update autolink settings for an existing project repository.
 *
 * Update autolink settings for an existing project repository.
 * Datasource: DB
 */
export const updateProjectRepoAutolinkSettings = <TComposable extends Composable = '$fetch', DefaultT extends UpdateProjectRepoAutolinkSettingsResponse = UpdateProjectRepoAutolinkSettingsResponse>(options: Options<TComposable, UpdateProjectRepoAutolinkSettingsData, UpdateProjectRepoAutolinkSettingsResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateProjectRepoAutolinkSettingsResponse | DefaultT, UpdateProjectRepoAutolinkSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/autolink',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Set autolink settings for an existing project repository.
 *
 * Set autolink settings for an existing project repository.
 * Datasource: DB
 */
export const setProjectRepoAutolinkSettings = <TComposable extends Composable = '$fetch', DefaultT extends SetProjectRepoAutolinkSettingsResponse = SetProjectRepoAutolinkSettingsResponse>(options: Options<TComposable, SetProjectRepoAutolinkSettingsData, SetProjectRepoAutolinkSettingsResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, SetProjectRepoAutolinkSettingsResponse | DefaultT, SetProjectRepoAutolinkSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/autolink',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Disable a project repository mirroring.
 *
 * Disable a project repository mirroring.
 * Datasource: DB, Job
 */
export const disableProjectRepoMirror = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DisableProjectRepoMirrorData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DisableProjectRepoMirrorError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/mirror',
        ...options
    });
};

/**
 * Get an existing project repository mirroring settings and state.
 *
 * Get an existing project repository mirroring settings and state.
 * Datasource: DB
 *
 * Warning! Response field 'data' can be empty as indication of not found (CODE-4087).
 */
export const getProjectRepoMirror = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoMirrorResponse = GetProjectRepoMirrorResponse>(options: Options<TComposable, GetProjectRepoMirrorData, GetProjectRepoMirrorResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoMirrorResponse | DefaultT, GetProjectRepoMirrorError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/mirror',
        ...options
    });
};

/**
 * Enable a project repository mirroring.
 *
 * Enable a project repository mirroring or update the mirror parameters.
 * Datasource: DB, Job
 */
export const enableProjectRepoMirror = <TComposable extends Composable = '$fetch', DefaultT extends EnableProjectRepoMirrorResponse = EnableProjectRepoMirrorResponse>(options: Options<TComposable, EnableProjectRepoMirrorData, EnableProjectRepoMirrorResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, EnableProjectRepoMirrorResponse | DefaultT, EnableProjectRepoMirrorError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/mirror',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get list an existing project repository pull request merge settings.
 *
 * Get list an existing project repository pull request merge settings.
 * Datasource: DB
 */
export const listProjectRepoPolicy = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectRepoPolicyResponse = ListProjectRepoPolicyResponse>(options: Options<TComposable, ListProjectRepoPolicyData, ListProjectRepoPolicyResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectRepoPolicyResponse | DefaultT, ListProjectRepoPolicyError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/policy',
        ...options
    });
};

/**
 * Set pull request merge settings for an existing project repository.
 *
 * Set pull request merge settings for an existing project repository.
 * Datasource: DB
 */
export const addProjectRepoPolicy = <TComposable extends Composable = '$fetch', DefaultT extends AddProjectRepoPolicyResponse = AddProjectRepoPolicyResponse>(options: Options<TComposable, AddProjectRepoPolicyData, AddProjectRepoPolicyResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, AddProjectRepoPolicyResponse | DefaultT, AddProjectRepoPolicyError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/policy',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get protected branches settings for an existing project repository.
 *
 * Get protected branches settings for an existing project repository.
 * Datasource: DB
 */
export const getProjectRepoProtectedBranchesSettings = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoProtectedBranchesSettingsResponse = GetProjectRepoProtectedBranchesSettingsResponse>(options: Options<TComposable, GetProjectRepoProtectedBranchesSettingsData, GetProjectRepoProtectedBranchesSettingsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoProtectedBranchesSettingsResponse | DefaultT, GetProjectRepoProtectedBranchesSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/protected_branches',
        ...options
    });
};

/**
 * Set protected branches settings for an existing project repository.
 *
 * Set protected branches settings for an existing project repository.
 * Datasource: DB
 */
export const setProjectRepoProtectedBranchesSettings = <TComposable extends Composable = '$fetch', DefaultT extends SetProjectRepoProtectedBranchesSettingsResponse = SetProjectRepoProtectedBranchesSettingsResponse>(options: Options<TComposable, SetProjectRepoProtectedBranchesSettingsData, SetProjectRepoProtectedBranchesSettingsResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, SetProjectRepoProtectedBranchesSettingsResponse | DefaultT, SetProjectRepoProtectedBranchesSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/protected_branches',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List repository reviewer groups settings.
 *
 * List repository reviewer groups settings.
 * Datasource: DB
 *
 * @deprecated
 */
export const listProjectRepoReviewerGroups = <TComposable extends Composable = '$fetch', DefaultT extends ListProjectRepoReviewerGroupsResponse = ListProjectRepoReviewerGroupsResponse>(options: Options<TComposable, ListProjectRepoReviewerGroupsData, ListProjectRepoReviewerGroupsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListProjectRepoReviewerGroupsResponse | DefaultT, ListProjectRepoReviewerGroupsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/reviewer_groups',
        ...options
    });
};

/**
 * Set repository reviewer group.
 *
 * Set repository reviewer group.
 * Datasource: DB
 *
 * @deprecated
 */
export const setProjectRepoReviewerGroup = <TComposable extends Composable = '$fetch', DefaultT extends SetProjectRepoReviewerGroupResponse = SetProjectRepoReviewerGroupResponse>(options: Options<TComposable, SetProjectRepoReviewerGroupData, SetProjectRepoReviewerGroupResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, SetProjectRepoReviewerGroupResponse | DefaultT, SetProjectRepoReviewerGroupError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/reviewer_groups',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete repository reviewer group.
 *
 * Delete repository reviewer group.
 * Datasource: DB
 *
 * @deprecated
 */
export const deleteProjectRepoReviewerGroup = <TComposable extends Composable = '$fetch', DefaultT extends DeleteProjectRepoReviewerGroupResponse = DeleteProjectRepoReviewerGroupResponse>(options: Options<TComposable, DeleteProjectRepoReviewerGroupData, DeleteProjectRepoReviewerGroupResponse, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, DeleteProjectRepoReviewerGroupResponse | DefaultT, DeleteProjectRepoReviewerGroupError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/reviewer_groups/{reviewerGroup}',
        ...options
    });
};

/**
 * Get repo search settings for an existing project repository.
 *
 * Get repo search settings for an existing project repository.
 * Datasource: DB
 * Warning! Response field 'data' can be empty as indication of disabled 'Codex' search service.
 */
export const getRepoSearchSettings = <TComposable extends Composable = '$fetch', DefaultT extends GetRepoSearchSettingsResponse = GetRepoSearchSettingsResponse>(options: Options<TComposable, GetRepoSearchSettingsData, GetRepoSearchSettingsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetRepoSearchSettingsResponse | DefaultT, GetRepoSearchSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/search',
        ...options
    });
};

/**
 * Set repo search settings for an existing project repository.
 *
 * Set repo search settings for an existing project repository.
 * Datasource: DB
 */
export const setRepoSearchSettings = <TComposable extends Composable = '$fetch', DefaultT extends SetRepoSearchSettingsResponse = SetRepoSearchSettingsResponse>(options: Options<TComposable, SetRepoSearchSettingsData, SetRepoSearchSettingsResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, SetRepoSearchSettingsResponse | DefaultT, SetRepoSearchSettingsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get list of structure branch setting.
 *
 * Get list of structure branch setting.
 * Datasource: DB
 */
export const listRepoStructureBranch = <TComposable extends Composable = '$fetch', DefaultT extends ListRepoStructureBranchResponse = ListRepoStructureBranchResponse>(options: Options<TComposable, ListRepoStructureBranchData, ListRepoStructureBranchResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListRepoStructureBranchResponse | DefaultT, ListRepoStructureBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/structure/branches',
        ...options
    });
};

/**
 * Create repo structure branch settings.
 *
 * Create repo structure branch settings.
 * Datasource: DB
 */
export const createRepoStructureBranch = <TComposable extends Composable = '$fetch', DefaultT extends CreateRepoStructureBranchResponse = CreateRepoStructureBranchResponse>(options: Options<TComposable, CreateRepoStructureBranchData, CreateRepoStructureBranchResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateRepoStructureBranchResponse | DefaultT, CreateRepoStructureBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/structure/branches',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete structure branch setting.
 *
 * Delete structure branch setting.
 * Datasource: DB
 */
export const deleteRepoStructureBranch = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteRepoStructureBranchData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteRepoStructureBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/structure/branches/{structureBranchId}',
        ...options
    });
};

/**
 * Update structure branch setting.
 *
 * Update structure branch setting.
 * Datasource: DB
 */
export const updateRepoStructureBranch = <TComposable extends Composable = '$fetch', DefaultT extends UpdateRepoStructureBranchResponse = UpdateRepoStructureBranchResponse>(options: Options<TComposable, UpdateRepoStructureBranchData, UpdateRepoStructureBranchResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateRepoStructureBranchResponse | DefaultT, UpdateRepoStructureBranchError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/structure/branches/{structureBranchId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get list of structure path setting.
 *
 * Get list of structure path setting.
 * Datasource: DB
 */
export const listRepoStructurePath = <TComposable extends Composable = '$fetch', DefaultT extends ListRepoStructurePathResponse = ListRepoStructurePathResponse>(options: Options<TComposable, ListRepoStructurePathData, ListRepoStructurePathResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListRepoStructurePathResponse | DefaultT, ListRepoStructurePathError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/structure/paths',
        ...options
    });
};

/**
 * Create repo structure path settings.
 *
 * Create repo structure path settings.
 * Datasource: DB
 */
export const createRepoStructurePath = <TComposable extends Composable = '$fetch', DefaultT extends CreateRepoStructurePathResponse = CreateRepoStructurePathResponse>(options: Options<TComposable, CreateRepoStructurePathData, CreateRepoStructurePathResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateRepoStructurePathResponse | DefaultT, CreateRepoStructurePathError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/settings/structure/paths',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List repository tags.
 *
 * List repository tags.
 */
export const listTags = <TComposable extends Composable = '$fetch', DefaultT extends ListTagsResponse = ListTagsResponse>(options: Options<TComposable, ListTagsData, ListTagsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListTagsResponse | DefaultT, ListTagsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/tags',
        ...options
    });
};

/**
 * Create repository tag.
 *
 * Create repository tag.
 */
export const createTag = <TComposable extends Composable = '$fetch', DefaultT extends CreateTagResponse = CreateTagResponse>(options: Options<TComposable, CreateTagData, CreateTagResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateTagResponse | DefaultT, CreateTagError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/tags',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete repository tag.
 *
 * Delete repository tag.
 */
export const deleteTag = <TComposable extends Composable = '$fetch', DefaultT extends DeleteTagResponse = DeleteTagResponse>(options: Options<TComposable, DeleteTagData, DeleteTagResponse, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, DeleteTagResponse | DefaultT, DeleteTagError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/tags/{tagName}',
        ...options
    });
};

/**
 * List a project repository tree metadata.
 *
 * List a project repository tree metadata.
 * Datasource: Git
 */
export const getProjectRepoTreeMetadata = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoTreeMetadataResponse = GetProjectRepoTreeMetadataResponse>(options: Options<TComposable, GetProjectRepoTreeMetadataData, GetProjectRepoTreeMetadataResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, GetProjectRepoTreeMetadataResponse | DefaultT, GetProjectRepoTreeMetadataError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/tree-metadata',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List a project repository tree.
 *
 * List a project repository tree.
 * Datasource: Git
 */
export const getProjectRepoTree = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoTreeResponse = GetProjectRepoTreeResponse>(options: Options<TComposable, GetProjectRepoTreeData, GetProjectRepoTreeResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoTreeResponse | DefaultT, GetProjectRepoTreeError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/tree/{treePath}',
        ...options
    });
};

/**
 * Get project repository usage quotas.
 *
 * Get project repository usage quotas.
 * Datasource: Git
 */
export const getRepoUsageQuotas = <TComposable extends Composable = '$fetch', DefaultT extends GetRepoUsageQuotasResponse = GetRepoUsageQuotasResponse>(options: Options<TComposable, GetRepoUsageQuotasData, GetRepoUsageQuotasResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetRepoUsageQuotasResponse | DefaultT, GetRepoUsageQuotasError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/usage-quotas',
        ...options
    });
};

/**
 * Get users by logins..
 *
 * Get users by logins.
 */
export const getUsersByLogins = <TComposable extends Composable = '$fetch', DefaultT extends GetUsersByLoginsResponse = GetUsersByLoginsResponse>(options: Options<TComposable, GetUsersByLoginsData, GetUsersByLoginsResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, GetUsersByLoginsResponse | DefaultT, GetUsersByLoginsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/users',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get an existing repository webhooks list.
 *
 * Get an existing repository webhooks list.
 * Datasource: DB
 */
export const getProjectRepoWebhooks = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoWebhooksResponse = GetProjectRepoWebhooksResponse>(options: Options<TComposable, GetProjectRepoWebhooksData, GetProjectRepoWebhooksResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoWebhooksResponse | DefaultT, GetProjectRepoWebhooksError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/webhooks',
        ...options
    });
};

/**
 * Create new webhook.
 *
 * Create new webhook.
 * Datasource: DB, Kafka
 */
export const createProjectRepoWebhook = <TComposable extends Composable = '$fetch', DefaultT extends CreateProjectRepoWebhookResponse = CreateProjectRepoWebhookResponse>(options: Options<TComposable, CreateProjectRepoWebhookData, CreateProjectRepoWebhookResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateProjectRepoWebhookResponse | DefaultT, CreateProjectRepoWebhookError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/webhooks',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Make a test connection.
 *
 * Make a test connection.
 * To date, it has worked with sfera.CI/CD.
 */
export const checkConnectionWebhook = <TComposable extends Composable = '$fetch', DefaultT extends CheckConnectionWebhookResponse = CheckConnectionWebhookResponse>(options: Options<TComposable, CheckConnectionWebhookData, CheckConnectionWebhookResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CheckConnectionWebhookResponse | DefaultT, CheckConnectionWebhookError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/webhooks/check',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete an existing webhook.
 *
 * Delete an existing webhook.
 * Datasource: DB, Kafka
 */
export const deleteProjectRepoWebhook = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteProjectRepoWebhookData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteProjectRepoWebhookError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/webhooks/{whId}',
        ...options
    });
};

/**
 * Get an existing repository webhook.
 *
 * Get an existing repository webhook.
 * Datasource: DB
 */
export const getProjectRepoWebhook = <TComposable extends Composable = '$fetch', DefaultT extends GetProjectRepoWebhookResponse = GetProjectRepoWebhookResponse>(options: Options<TComposable, GetProjectRepoWebhookData, GetProjectRepoWebhookResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetProjectRepoWebhookResponse | DefaultT, GetProjectRepoWebhookError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/webhooks/{whId}',
        ...options
    });
};

/**
 * Update an existing webhook.
 *
 * Update an existing webhook fields.
 * Datasource: DB, Kafka
 */
export const updateProjectRepoWebhook = <TComposable extends Composable = '$fetch', DefaultT extends UpdateProjectRepoWebhookResponse = UpdateProjectRepoWebhookResponse>(options: Options<TComposable, UpdateProjectRepoWebhookData, UpdateProjectRepoWebhookResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateProjectRepoWebhookResponse | DefaultT, UpdateProjectRepoWebhookError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/repos/{repoName}/webhooks/{whId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List project service accounts.
 *
 * List of project service accounts.
 * Datasource: DB
 */
export const listServiceAccounts = <TComposable extends Composable = '$fetch', DefaultT extends ListServiceAccountsResponse = ListServiceAccountsResponse>(options: Options<TComposable, ListServiceAccountsData, ListServiceAccountsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListServiceAccountsResponse | DefaultT, ListServiceAccountsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/service-accounts/',
        ...options
    });
};

/**
 * Create a new project service account.
 *
 * Create a new project service account.
 * Datasource: DB
 */
export const createServiceAccount = <TComposable extends Composable = '$fetch', DefaultT extends CreateServiceAccountResponse = CreateServiceAccountResponse>(options: Options<TComposable, CreateServiceAccountData, CreateServiceAccountResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, CreateServiceAccountResponse | DefaultT, CreateServiceAccountError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/service-accounts/',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete an existing project service account.
 *
 * Delete an existing project service account.
 * Datasource: DB
 */
export const deleteServiceAccount = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteServiceAccountData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteServiceAccountError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/service-accounts/{saName}',
        ...options
    });
};

/**
 * Get an existing project service account.
 *
 * Get an existing project service account.
 * Datasource: DB
 */
export const getServiceAccount = <TComposable extends Composable = '$fetch', DefaultT extends GetServiceAccountResponse = GetServiceAccountResponse>(options: Options<TComposable, GetServiceAccountData, GetServiceAccountResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetServiceAccountResponse | DefaultT, GetServiceAccountError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/service-accounts/{saName}',
        ...options
    });
};

/**
 * Update an existing project account service.
 *
 * Update an existing project service account fields. At least one input field must be provided.
 * Datasource: DB
 */
export const updateServiceAccount = <TComposable extends Composable = '$fetch', DefaultT extends UpdateServiceAccountResponse = UpdateServiceAccountResponse>(options: Options<TComposable, UpdateServiceAccountData, UpdateServiceAccountResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateServiceAccountResponse | DefaultT, UpdateServiceAccountError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/service-accounts/{saName}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Entities info by service accounts.
 *
 * Entities info of project service accounts.
 * Datasource: DB
 */
export const listServiceAccountEntities = <TComposable extends Composable = '$fetch', DefaultT extends ListServiceAccountEntitiesResponse = ListServiceAccountEntitiesResponse>(options: Options<TComposable, ListServiceAccountEntitiesData, ListServiceAccountEntitiesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListServiceAccountEntitiesResponse | DefaultT, ListServiceAccountEntitiesError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/service-accounts/{saName}/entities',
        ...options
    });
};

/**
 * Get project usage quotas settings. Includes soft and hard for file and repository add-ons.
 *
 * Get project setting usage quotas. Includes soft and hard for file and repository add-ons.
 * Datasource: DB
 */
export const getUsageQuotasSettingsProject = <TComposable extends Composable = '$fetch', DefaultT extends GetUsageQuotasSettingsProjectResponse = GetUsageQuotasSettingsProjectResponse>(options: Options<TComposable, GetUsageQuotasSettingsProjectData, GetUsageQuotasSettingsProjectResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetUsageQuotasSettingsProjectResponse | DefaultT, GetUsageQuotasSettingsProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/settings/usage-quotas',
        ...options
    });
};

/**
 * Update project usage quotas settings. Includes basic, soft and hard for file and repository add-ons.
 *
 * Update project setting usage quotas. Includes basic, soft and hard for file and repository add-ons. Min: 1MB, Max: 100GB.
 * Datasource: DB
 */
export const putUsageQuotasSettingsProject = <TComposable extends Composable = '$fetch', DefaultT extends PutUsageQuotasSettingsProjectResponse = PutUsageQuotasSettingsProjectResponse>(options: Options<TComposable, PutUsageQuotasSettingsProjectData, PutUsageQuotasSettingsProjectResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, PutUsageQuotasSettingsProjectResponse | DefaultT, PutUsageQuotasSettingsProjectError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects/{projectKey}/settings/usage-quotas',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get service information.
 *
 * Get service information from label names.
 * Datasource: DB
 */
export const getServiceInformation = <TComposable extends Composable = '$fetch', DefaultT extends GetServiceInformationResponse = GetServiceInformationResponse>(options: Options<TComposable, GetServiceInformationData, GetServiceInformationResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetServiceInformationResponse | DefaultT, GetServiceInformationError, DefaultT>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/service-information',
        ...options
    });
};

/**
 * Create notification subscription.
 *
 * Create notification subscription.
 * One must specify the subscription object and subscription type.
 * Datasource: DB
 */
export const addNotificationSubscription = <TComposable extends Composable = '$fetch', DefaultT extends AddNotificationSubscriptionResponse = AddNotificationSubscriptionResponse>(options: Options<TComposable, AddNotificationSubscriptionData, AddNotificationSubscriptionResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, AddNotificationSubscriptionResponse | DefaultT, AddNotificationSubscriptionError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/subscribe',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get notification subscription info in regard of requester.
 *
 * Get notification subscription info in regard of requester.
 * Datasource: DB.
 */
export const getNotificationSubscriptionInfo = <TComposable extends Composable = '$fetch', DefaultT extends GetNotificationSubscriptionInfoResponse = GetNotificationSubscriptionInfoResponse>(options: Options<TComposable, GetNotificationSubscriptionInfoData, GetNotificationSubscriptionInfoResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetNotificationSubscriptionInfoResponse | DefaultT, GetNotificationSubscriptionInfoError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/subscription-info',
        ...options
    });
};

/**
 * Get notification subscriptions.
 *
 * Get notification subscriptions.
 * Datasource: DB
 */
export const getNotificationSubscriptions = <TComposable extends Composable = '$fetch', DefaultT extends GetNotificationSubscriptionsResponse = GetNotificationSubscriptionsResponse>(options: Options<TComposable, GetNotificationSubscriptionsData, GetNotificationSubscriptionsResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetNotificationSubscriptionsResponse | DefaultT, GetNotificationSubscriptionsError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/subscriptions',
        ...options
    });
};

/**
 * Unsubscribe from notifications.
 *
 * Unsubscribe from notifications.
 * Datasource: DB.
 */
export const deleteNotificationSubscription = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteNotificationSubscriptionData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteNotificationSubscriptionError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/unsubscribe',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List users
 *
 * Paginated list of users.
 * Datasource: DB
 */
export const listUsers = <TComposable extends Composable = '$fetch', DefaultT extends ListUsersResponse = ListUsersResponse>(options: Options<TComposable, ListUsersData, ListUsersResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListUsersResponse | DefaultT, ListUsersError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users',
        ...options
    });
};

/**
 * List user public keys for SSH access.
 *
 * List user public keys for SSH access.
 * Datasource: DB
 */
export const listPublicKeys = <TComposable extends Composable = '$fetch', DefaultT extends ListPublicKeysResponse = ListPublicKeysResponse>(options: Options<TComposable, ListPublicKeysData, ListPublicKeysResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListPublicKeysResponse | DefaultT, ListPublicKeysError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/keys',
        ...options
    });
};

/**
 * Create a new user public key for SSH access.
 *
 * Create a new user public key for SSH access.
 * Datasource: DB
 */
export const createPublicKey = <TComposable extends Composable = '$fetch', DefaultT extends CreatePublicKeyResponse = CreatePublicKeyResponse>(options: Options<TComposable, CreatePublicKeyData, CreatePublicKeyResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreatePublicKeyResponse | DefaultT, CreatePublicKeyError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/keys',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete an existing user public key for SSH access.
 *
 * Delete an existing user public key for SSH access.
 * Datasource: DB
 */
export const deletePublicKey = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeletePublicKeyData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeletePublicKeyError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/keys/{fingerprint}',
        ...options
    });
};

/**
 * Update an existing user public key for SSH access.
 *
 * Update an existing user public key for SSH access.
 * Datasource: DB
 */
export const updatePublicKey = <TComposable extends Composable = '$fetch', DefaultT extends UpdatePublicKeyResponse = UpdatePublicKeyResponse>(options: Options<TComposable, UpdatePublicKeyData, UpdatePublicKeyResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdatePublicKeyResponse | DefaultT, UpdatePublicKeyError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/keys/{fingerprint}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get the current user information.
 *
 * Get the current user information.
 * Datasource: DB
 */
export const self = <TComposable extends Composable = '$fetch', DefaultT extends SelfResponse = SelfResponse>(options: Options<TComposable, SelfData, SelfResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, SelfResponse | DefaultT, SelfError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/self',
        ...options
    });
};

/**
 * List user access tokens.
 *
 * List user access tokens.
 * Datasource: DB
 */
export const listTokens = <TComposable extends Composable = '$fetch', DefaultT extends ListTokensResponse = ListTokensResponse>(options: Options<TComposable, ListTokensData, ListTokensResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ListTokensResponse | DefaultT, ListTokensError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/tokens',
        ...options
    });
};

/**
 * Create a new user access token.
 *
 * Create a new user access token.
 * Datasource: DB
 */
export const createToken = <TComposable extends Composable = '$fetch', DefaultT extends CreateTokenResponse = CreateTokenResponse>(options: Options<TComposable, CreateTokenData, CreateTokenResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CreateTokenResponse | DefaultT, CreateTokenError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/tokens',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete an existing user access token.
 *
 * Delete an existing user access token.
 * Datasource: DB
 */
export const deleteToken = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteTokenData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, DeleteTokenError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/tokens/{tokenHash}',
        ...options
    });
};

/**
 * Update an existing user access token.
 *
 * Update an existing user access token.
 * Datasource: DB
 */
export const updateToken = <TComposable extends Composable = '$fetch', DefaultT extends UpdateTokenResponse = UpdateTokenResponse>(options: Options<TComposable, UpdateTokenData, UpdateTokenResponse, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, UpdateTokenResponse | DefaultT, UpdateTokenError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/tokens/{tokenHash}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Check user token existence.
 *
 * Check user token existence.
 * Datasource: DB
 */
export const checkToken = <TComposable extends Composable = '$fetch', DefaultT extends CheckTokenResponse = CheckTokenResponse>(options: Options<TComposable, CheckTokenData, CheckTokenResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CheckTokenResponse | DefaultT, CheckTokenError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/tokens/{token}/check',
        ...options
    });
};

/**
 * Get an existing user information.
 *
 * Get an existing user information.
 * Datasource: DB
 */
export const getUser = <TComposable extends Composable = '$fetch', DefaultT extends GetUserResponse = GetUserResponse>(options: Options<TComposable, GetUserData, GetUserResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetUserResponse | DefaultT, GetUserError, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/users/{username}',
        ...options
    });
};

/**
 * Version app and build time
 *
 * Get release number and build time
 */
export const versionCheck = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, VersionCheckData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/version',
        ...options
    });
};
